.. meta::
   :description: この論文はA*(A Star)アルゴリズムが提唱された論文である.
   :keywords: A* algorithm, A star algorithm


=====================================================================
A Formal Basis for the Heuristic Determination of Minimum Cost Paths
=====================================================================

.. include:: /_include/ref/a_star.txt
   
.. contents:: contents
   :depth: 3


Introduction
======================================================================

The problem of finding paths through graphs
----------------------------------------------------------------------
グラフ理論において最短経路を求める手法を, ここでは `mathematical approach` と `heuristic approach` に分けている.

- methematical approachというのは, 任意のグラフについての一般論を引き出そうとするアプローチのことを言おうとしているのだと思う. あらゆるグラフに対して最短経路を求められることが保証されている手法の解析など. 計算量の観点には配慮がないとか.
- heuristic approachというのは, グラフとして表現されている問題のdomainに関する特殊な知識を用いる手法のことであり, 計算効率を上げることを目的にしている. 枝狩りを用いるということだろう. heuristic approachを用いている手法は概して, 最短コストの経路を見つけられることが保証されていない.

この論文で提唱される方法は, 緩い仮定のもとで, 最短経路を保証する経路を求める際に走査するノードの数を最小化するという意味でoptimalであることを証明する.

最小コストを求めたい2つのノードが与えられた時に, 「その経路の実際の最短コストよりはギリギリ少し大きい」ような評価関数を見つけることができれば, それを使ってグラフを探査することで, 走査するノードの数を減らすことができる.


Some definitions about graphs
----------------------------------------------------------------------
グラフ理論の教科書にのっているような定義が書かれている. ノードの集合 :math:`\{ n_i \}` とエッジの集合  :math:`\{ e_{pq} \}` があり, それぞれのエッジにはコストが定められている. また有向グラフである場合,  :math:`e_{ij}` と :math:`e_{ji}` の値は異なる. エッジのコストの最小値を :math:`\delta` としたとき, そのグラフを :math:`G_{\delta}` と表す.

この論文で扱うようなアプリケーションにおいては, グラフの各エッジに対してコストが与えられていることはなく. その代わりimplicitlyにソースノード集合 :math:`S \in \{ n_j \}` と, successor operator  :math:`\Gamma` が与えられている.  :math:`\Gamma` は各ノードに対して, 別のノードへのコストのリスト :math:`\{ n_j, c_{ij} \}` を返す関数である. successor operatorを初期のノードリスト, そのsuccessor, 更にその先へと, これ以上新しいノードが見つからなくなるまで適用することで, グラフをexplicitlyに表現することもできる.

subgraph  :math:`G_n` は,  :math:`\{ n_i \}` の中のいずれかのノード :math:`n` からsuccessor  :math:`\Gamma` を用いて「ひとつだけ伸ばして」作られるグラフのこと.

あるノードからそのpreferred goal nodeへの最短経路のコストを,  :math:`h(n)` と表記する.

An admissible searching algorithm
======================================================================
ノード :math:`n_i` から :math:`n_j` へのoptimal costのことを :math:`h(n_i, n_j)` と表記する. これは :math:`n_i` から :math:`n_j` の間に最短コストの経路が存在している場合のその値である(連結でなければそもそも定義されないので).

一応この論文ではゴールとなるノードが複数ある場合を考えている. そのゴール集号のことを  :math:`T` , そのノードの中でもソースノードsからの最小コストが最も小さいノードのことをpreferred nodeと呼び, その時のコストのことを :math:`h(n)` と呼ぶ. これは動的計画法で言うところの真の価値関数というところだろう.

Algorithms for finding minimum cost paths
----------------------------------------------------------------------
ソースノードsからスタートして :math:`\Gamma` を適用してsubgraph :math:`G_s` を構築することを `expand node` と表現する.

ソースノードsから訪問した各ノードへの最短経路は, 次のようにして辿ることができる. successorにより, あるノードnへとエッジがexpandされた時, そのノードnに  ``向かう`` エッジの中で, ノードnへの累積コストが最も短くなるものを選ぶ. そしてノードnに, その最小累積コストとその時の親を格納する. この操作をgoal nodeのtに到達するまで続ける. そしてtからsへと逆向きに辿ればいい.

与えられたソースノードsからpreferred goalへのoptimal solutionを求められるアルゴリズムのことを `admissible` という. グラフが与えられた時に, そのノードを走査する順番や走査する必要のあるノードの数はアルゴリズムによって異なる. 次の章では `admissible` な解を得るためのノードを辿る順番について, その次の章で, 緩やかな仮定のもとで, その方法により, optimal pathを最も少ないノード数で見つけられることを示す.

Description of the algorithm
----------------------------------------------------------------------
最短経路を探索する際に辿る必要のあるノード数を出来る限り少なくするためには, 次に走査する必要のあるノードについて, 出来る限り **知識あり** の決定を行う必要がある. そのため, optimal pathを与える可能性のあるノードを無視してしまうとadmissibleな解を得ることができない.

評価関数として :math:`\hat{f}(n)` を各ノードについて評価することができるとする. そしてその時点で :math:`\hat{f}(n)` の値が最も小さいノードを次に `expand` するノードとして用いる. 

:Search Algorithm A\*:

0. sを *open list* に入れて :math:`\hat{f}(s)` を求める
1. *open list* の中で最も :math:`\hat{f}(n)` の値が小さいnを求める
2. nを *closed list* に入れる. そしてnからsuccessor  :math:`\Gamma` を適用する(エッジを辿る). そしてその中でまだ *closed list* に入っていないものを *open list* に入れる. つまり *open list* に入っているノードは子を持たない **葉** であるか(まだ探索されていなかった)あるいはまだ探索の余地がある(更新される際にコストが下がった), そして *closed list* に入っているノードは **枝** になっている(基本的には探索の対象とはしない. 枝刈りの対象). そして各々の :math:`\hat{f}(n)` を更新する.
3. 一方 *closed list* に入っていたノードの中で,  :math:`\hat{f}(n)` が下がったものは, 再び *open list* に入れる. つまり上の手順で枝刈りされたけど(*closed list* に入れられたけど)再び探索対象に入れる.
4. 手順1に戻る

The evaluation function
----------------------------------------------------------------------
ソースノードsからゴールノードgへの最短経路を考えた時に, その中でノードnを通るという制約を加えた時の最短経路のコストを,  :math:`f(n)` と表記する. つまり :math:`f(s) = h(s)` である. そしてｓからｇへの最短経路上に存在するノードｎについては, いずれも :math:`f(n) = f(s)` を満たしている. そしてｓからｇへの最短経路上に存在しないノードについては :math:`f(n) > f(s)` である. 各ノードについて :math:`f(n)` を求めるためには動的計画法を厳密に行う必要があるが, その関数の近似関数 :math:`\hat{f}(n)` を探索の途中の「次にどこから伸ばすか」を決めるための評価関数として用いるのは妥当そうである. 始点から探索を開始したのなら, その時点で各ノードについては


.. math::
   :nowrap:

   \begin{align*}
   f(n) = g(n) + h(n)
   \end{align*}

のようにして, 現時点でのすでに分かっている, 始点からのコスト :math:`g(n)` とまだ未知の終点へのコスト関数 :math:`g(n)` に分けることができる. 問題は :math:`h(n)` として何を用いるかである.

初めに, もし :math:`\hat{f}(n)` が :math:`h(n)` の下界に属していれば, A\*アルゴリズムはadmissibleであることを証明する.

The admissibility of A\*
----------------------------------------------------------------------

:Lemma1:


On the optimiality of A\*
======================================================================

Limitations of subgraphs by information from the problem
----------------------------------------------------------------------

A consistency assumption
----------------------------------------------------------------------

Proof of the optimality of A\*
----------------------------------------------------------------------

Discusstion and conclusions
======================================================================
